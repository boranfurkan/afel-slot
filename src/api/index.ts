/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * AFEL Discovery API Documentation
 * The AFEL Discovery API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { getAxiosInstance } from './AxiosInstance';
export interface S3Request {
  clientId: string;
  clientSecret: string;
}

export interface FileRequest {
  clientId: string;
  clientSecret: string;
  key: string;
}

export interface UseReferralCodeRequest {
  /** Referance code */
  referalCode: string;
}

export interface ReferedUserDto {
  readonly accountId: string;
  readonly afelId: string;
  readonly referedDate: string;
}

export interface GetAccountReferralRelationsDto {
  readonly accountId: string;
  readonly afelId: string;
  readonly referedUsers: readonly ReferedUserDto[];
}

export interface BalanceResponse {
  readonly tokenType: string;
  readonly balance: string;
  readonly availableBalance: string;
  readonly totalBlockedAmount: string;
  readonly activeBlockages: readonly string[];
}

/**
 * Type of token
 */
export type WalletDepositRequestTokenType = typeof WalletDepositRequestTokenType[keyof typeof WalletDepositRequestTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WalletDepositRequestTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface WalletDepositRequest {
  /** Idempotent reference ID */
  referenceId: string;
  /** Type of token */
  tokenType: WalletDepositRequestTokenType;
  /** AFEL accountId */
  accountId: string;
  /** Amount to deposit */
  amount: string;
  /** Transaction signature */
  chainTrxId: string;
  /** Sender wallet address */
  senderWalletAddress: string;
  /** Receiver wallet address */
  receiverWalletAddress: string;
}

export interface WalletDepositResponse {
  readonly transactionId: string;
  readonly oldBalance: string;
  readonly addedAmount: string;
  readonly newBalance: string;
}

/**
 * Type of token
 */
export type PrizeDepositRequestTokenType = typeof PrizeDepositRequestTokenType[keyof typeof PrizeDepositRequestTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PrizeDepositRequestTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface PrizeDepositRequest {
  /** Idempotent reference ID */
  referenceId: string;
  /** Type of token */
  tokenType: PrizeDepositRequestTokenType;
  /** AFEL accountId */
  accountId: string;
  /** Amount to deposit */
  amount: string;
  /** Type of prize, e.g. FIRST_FIVE_GAME, DEFAULT, AIRDROP, etc... */
  type: string;
}

export interface PrizeDepositResponse {
  readonly transactionId: string;
  readonly oldBalance: string;
  readonly addedAmount: string;
  readonly newBalance: string;
}

export interface GameRankDto {
  /** Rank of the player */
  rank: number;
  /** Player accountId */
  accountId: string;
  /** Player wallet address */
  walletAddress: string;
}

/**
 * Type of token
 */
export type GameDepositRequestTokenType = typeof GameDepositRequestTokenType[keyof typeof GameDepositRequestTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GameDepositRequestTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface GameDepositRequest {
  /** Idempotent reference ID */
  referenceId: string;
  /** Type of token */
  tokenType: GameDepositRequestTokenType;
  /** Game unique identifier */
  gameId: string;
  /** Total bet amount for the game */
  totalBetAmount: string;
  /** Game ranks and accountIds */
  gameRanks: GameRankDto[];
  /** Total number of players */
  totalPlayers: number;
}

export interface GameDepositCommissionResponse {
  readonly rate: string;
  readonly amount: string;
  readonly txId: string;
}

export interface GamePlayerResult {
  readonly rank: number;
  readonly accountId: string;
  readonly oldBalance: string;
  readonly newBalance: string;
  readonly addedAmount: string;
  readonly nftCount: number;
  readonly commission: GameDepositCommissionResponse;
}

export interface GameDepositResponse {
  readonly transactionId: string;
  readonly gameId: string;
  readonly totalBetAmount: string;
  readonly processedBlockages: number;
  readonly winnerBlockageAmount: string;
  readonly totalBurnedAmount: string;
  readonly results: readonly GamePlayerResult[];
}

/**
 * Type of token to block
 */
export type WithdrawRequestDtoTokenType = typeof WithdrawRequestDtoTokenType[keyof typeof WithdrawRequestDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WithdrawRequestDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface WithdrawRequestDto {
  referenceId: string;
  /** Account ID to withdraw from */
  accountId: string;
  /** Type of token to block */
  tokenType: WithdrawRequestDtoTokenType;
  /** Amount of money to withdraw */
  amount: string;
  /** Destination address to send the money */
  destinationAddress: string;
}

export interface TokenBalance {
  readonly tokenType: string;
  readonly oldBalance: string;
  readonly newBalance: string;
}

export interface WithdrawResponse {
  readonly rpcTransactionId: string;
  readonly transferredAmount: string;
  readonly balances: readonly TokenBalance[];
}

/**
 * Type of token to AFEL ecosystem
 */
export type AddBlockageDtoTokenType = typeof AddBlockageDtoTokenType[keyof typeof AddBlockageDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddBlockageDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface AddBlockageDto {
  /** Reference ID for the transaction */
  referenceId: string;
  /** Afel accountId */
  accountId: string;
  /** Afel gameId */
  gameId: string;
  /** Amount of money to block */
  amount: string;
  /** Type of token to AFEL ecosystem */
  tokenType: AddBlockageDtoTokenType;
}

export type AddBlockageResponseType = typeof AddBlockageResponseType[keyof typeof AddBlockageResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddBlockageResponseType = {
  BLOCKED: 'BLOCKED',
  UNBLOCKED: 'UNBLOCKED',
  BURNED: 'BURNED',
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  FEE: 'FEE',
  BURN: 'BURN',
} as const;

export interface AddBlockageResponse {
  readonly blockageId: string;
  readonly type: AddBlockageResponseType;
  readonly amount: string;
  readonly gameId: string;
  readonly createdAt: string;
}

export interface RemoveBlockageDto {
  /** Account ID to remove blockage from */
  accountId: string;
  /** Blockage ID to remove */
  blockageId: string;
}

export interface RemoveBlockageResponse {
  readonly blockageId: string;
  readonly type: string;
  readonly amount: string;
  readonly gameId: string;
  readonly removedAt: string;
}

export interface RemoveMultipleBlockagesDto {
  /** Reference ID for the transaction */
  referenceId: string;
  accountIds: string[];
  blockageIds: string[];
}

export type RemovedBlockageItemDtoStatus = typeof RemovedBlockageItemDtoStatus[keyof typeof RemovedBlockageItemDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemovedBlockageItemDtoStatus = {
  INITIALIZED: 'INITIALIZED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  ACTIVE: 'ACTIVE',
} as const;

export interface RemovedBlockageItemDto {
  readonly blockageId: string;
  readonly status: RemovedBlockageItemDtoStatus;
  readonly amount: number;
  readonly gameId: string;
  readonly removedAt: string;
}

export interface RemoveMultipleBlockagesResponseDto {
  readonly removedBlockages: readonly RemovedBlockageItemDto[];
  readonly totalCount: number;
  readonly totalAmount: string;
}

export type ActiveBlockageItemDtoTokenType = typeof ActiveBlockageItemDtoTokenType[keyof typeof ActiveBlockageItemDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActiveBlockageItemDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type ActiveBlockageItemDtoType = typeof ActiveBlockageItemDtoType[keyof typeof ActiveBlockageItemDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActiveBlockageItemDtoType = {
  BLOCKED: 'BLOCKED',
  UNBLOCKED: 'UNBLOCKED',
  BURNED: 'BURNED',
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  FEE: 'FEE',
  BURN: 'BURN',
} as const;

export type ActiveBlockageItemDtoStatus = typeof ActiveBlockageItemDtoStatus[keyof typeof ActiveBlockageItemDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActiveBlockageItemDtoStatus = {
  INITIALIZED: 'INITIALIZED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  ACTIVE: 'ACTIVE',
} as const;

export interface ActiveBlockageItemDto {
  readonly id: string;
  readonly gameId: string;
  readonly amount: string;
  readonly tokenType: ActiveBlockageItemDtoTokenType;
  readonly type: ActiveBlockageItemDtoType;
  readonly status: ActiveBlockageItemDtoStatus;
  readonly createdAt: string;
}

export interface ActiveBlockagesResponseDto {
  readonly blockages: readonly ActiveBlockageItemDto[];
  readonly totalBlockedAmount: string;
}

export type BlockageHistoryItemDtoTokenType = typeof BlockageHistoryItemDtoTokenType[keyof typeof BlockageHistoryItemDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BlockageHistoryItemDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type BlockageHistoryItemDtoType = typeof BlockageHistoryItemDtoType[keyof typeof BlockageHistoryItemDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BlockageHistoryItemDtoType = {
  BLOCKED: 'BLOCKED',
  UNBLOCKED: 'UNBLOCKED',
  BURNED: 'BURNED',
  DEPOSIT: 'DEPOSIT',
  WITHDRAW: 'WITHDRAW',
  FEE: 'FEE',
  BURN: 'BURN',
} as const;

export type BlockageHistoryItemDtoStatus = typeof BlockageHistoryItemDtoStatus[keyof typeof BlockageHistoryItemDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BlockageHistoryItemDtoStatus = {
  INITIALIZED: 'INITIALIZED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  ACTIVE: 'ACTIVE',
} as const;

export interface BlockageHistoryItemDto {
  readonly id: string;
  readonly gameId: string;
  readonly amount: string;
  readonly tokenType: BlockageHistoryItemDtoTokenType;
  readonly type: BlockageHistoryItemDtoType;
  readonly status: BlockageHistoryItemDtoStatus;
  readonly createdAt: string;
  readonly deletedAt: string;
}

export interface BlockageHistoryResponseDto {
  readonly blockages: readonly BlockageHistoryItemDto[];
  readonly total: number;
  readonly limit: number;
  readonly offset: number;
}

/**
 * Type of token to block
 */
export type BurnBlockageDtoTokenType = typeof BurnBlockageDtoTokenType[keyof typeof BurnBlockageDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BurnBlockageDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface BurnBlockageDto {
  accountId: string;
  /** Type of token to block */
  tokenType: BurnBlockageDtoTokenType;
  /** Blockage ID to burn */
  blockageId: string;
  /** Afel gameId */
  gameId: string;
}

export interface BurnBlockageResponse {
  readonly blockageId: string;
  readonly gameId: string;
  readonly burnedAmount: string;
  readonly oldBalance: string;
  readonly newBalance: string;
  readonly burnedAt: string;
}

export interface NFTMetadataDto {
  /** NFT mint address */
  mintAddress: string;
  /** NFT name */
  name: string;
  /** NFT metadata URI */
  uri: string;
  /** NFT freeze status */
  isFrozen: boolean;
  /** NFT freeze delegate status */
  freezeDelegate: boolean;
}

export interface FreezeNFTsRequestDto {
  /** Wallet address */
  walletAddress: string;
  /** Array of NFT mint addresses */
  mintAddresses: string[];
}

export interface TransactionResponseDto {
  /** Array of serialized transactions */
  transactions: string[];
}

export interface FinalizeTransactionRequestDto {
  /** Base64 encoded signed transaction */
  signedTransaction: string;
}

export interface TransactionSignatureDto {
  /** Transaction signature */
  signature: string;
}

export interface WalletStatsDto {
  readonly address: string;
  readonly totalPoints: number;
  readonly stakedNFTCount: number;
  readonly totalNFTCount: number;
  readonly stakedSince: number;
  readonly frozenPercentage: number;
}

export interface StakedNFTDto {
  /** NFT mint address */
  mintAddress: string;
  /** NFT name */
  name: string;
  /** Staking start date */
  frozenDate: string;
  /** Points earned */
  points: number;
}

/**
 * Points per NFT
 */
export type WalletPointsDtoNftPoints = { [key: string]: unknown };

export interface WalletPointsDto {
  /** Total points */
  totalPoints: number;
  /** Points per NFT */
  nftPoints: WalletPointsDtoNftPoints;
}

export interface LeaderboardEntryDto {
  /** Wallet address */
  walletAddress: string;
  /** Total points */
  totalPoints: number;
  /** Number of staked NFTs */
  stakedNFTs: number;
}

export interface LeaderboardResponseDto {
  items: LeaderboardEntryDto[];
  /** Total number of entries */
  total: number;
}

export type TransactionStatusDtoStatus = typeof TransactionStatusDtoStatus[keyof typeof TransactionStatusDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatusDtoStatus = {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED',
} as const;

export interface TransactionStatusDto {
  status: TransactionStatusDtoStatus;
  /** Transaction signature */
  walletAddress: string;
  /** Stake Status */
  action: string;
  /** Confirmed at */
  confirmedAt: string;
  /** Error message */
  error: string;
}

export interface CheckTickerResponse {
  readonly userTotalTicketCount: number;
  readonly systemTotalTicketCount: number;
}

export interface PaginationMetadata {
  /** Total number of NFTs matching the filters */
  totalItems: number;
  /** Total number of pages */
  totalPages: number;
  /** Current page number */
  currentPage: number;
  /** Number of items per page */
  itemsPerPage: number;
  /** Indicates if there is a next page */
  hasNextPage: boolean;
  /** Indicates if there is a previous page */
  hasPreviousPage: boolean;
  /** Number of items on the current page */
  itemCount: number;
  /** Starting index of current page */
  startIndex: number;
  /** Ending index of current page */
  endIndex: number;
}

export interface PaginatedResponseDto {
  /** List of NFTs matching the filters */
  items: string[];
  /** Pagination metadata */
  meta: PaginationMetadata;
}

export interface WaitingListStatusResponse {
  readonly position: number;
  readonly potentialOgCount: number;
  readonly priority: number;
}

export interface AccountTokenStatusResponse {
  readonly totalOgSpot: number;
  readonly assignedOgSpots: number;
  readonly remainingOgSpots: number;
  readonly ogTokenRequirement: number;
  readonly wlTokenRequirement: number;
  readonly maxOgPerAccount: number;
  readonly totalOg: number;
  readonly totalWl: number;
  readonly waitingListStatus: WaitingListStatusResponse;
}

/**
 * The type of token being used for the bet (SOL or AFEL)
 */
export type PlaySlotMachineDtoTokenType = typeof PlaySlotMachineDtoTokenType[keyof typeof PlaySlotMachineDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlaySlotMachineDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface PlaySlotMachineDto {
  /** Unique identifier of the user account playing the slot machine */
  accountId: string;
  /** The amount to bet on this slot machine game (minimum 0.01) */
  betAmount: number;
  /** The type of token being used for the bet (SOL or AFEL) */
  tokenType: PlaySlotMachineDtoTokenType;
  /** Unique reference ID to ensure idempotency of transactions */
  referenceId: string;
}

export type SlotMachineResultDtoTokenType = typeof SlotMachineResultDtoTokenType[keyof typeof SlotMachineResultDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SlotMachineResultDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type SlotMachineResultDtoWinningLinesItem = { [key: string]: unknown };

export interface SlotMachineResultDto {
  readonly symbols: readonly string[];
  readonly won: boolean;
  readonly multiplier: number;
  readonly betAmount: number;
  readonly winAmount: number;
  readonly balanceBefore: number;
  readonly balanceAfter: number;
  readonly tokenType: SlotMachineResultDtoTokenType;
  readonly transactionId: string;
  readonly winningLines: readonly SlotMachineResultDtoWinningLinesItem[];
}

export type SlotMachineHistoryItemTokenType = typeof SlotMachineHistoryItemTokenType[keyof typeof SlotMachineHistoryItemTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SlotMachineHistoryItemTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface SlotMachineHistoryItem {
  readonly id: string;
  readonly symbols: readonly string[];
  readonly betAmount: number;
  readonly winAmount: number;
  readonly multiplier: number;
  readonly won: boolean;
  readonly tokenType: SlotMachineHistoryItemTokenType;
  readonly createdAt: string;
}

export interface SlotMachineHistoryResponse {
  readonly items: readonly SlotMachineHistoryItem[];
  readonly total: number;
  readonly page: number;
  readonly limit: number;
}

export type SlotMachineStatsSymbolFrequency = { [key: string]: unknown };

export type SlotMachineStatsTokenType = typeof SlotMachineStatsTokenType[keyof typeof SlotMachineStatsTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SlotMachineStatsTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface SlotMachineStats {
  readonly totalGames: number;
  readonly wins: number;
  readonly losses: number;
  readonly winRate: number;
  readonly totalBetAmount: number;
  readonly totalWinAmount: number;
  readonly netProfit: number;
  readonly avgMultiplier: number;
  readonly symbolFrequency: SlotMachineStatsSymbolFrequency;
  readonly largestWin: number;
  readonly tokenType: SlotMachineStatsTokenType;
}

/**
 * The side of the coin the player is betting on (HEADS or TAILS)
 */
export type PlayCoinFlipDtoChoice = typeof PlayCoinFlipDtoChoice[keyof typeof PlayCoinFlipDtoChoice];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlayCoinFlipDtoChoice = {
  HEADS: 'HEADS',
  TAILS: 'TAILS',
} as const;

/**
 * The type of token being used for the bet (SOL or AFEL)
 */
export type PlayCoinFlipDtoTokenType = typeof PlayCoinFlipDtoTokenType[keyof typeof PlayCoinFlipDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlayCoinFlipDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface PlayCoinFlipDto {
  /** Unique identifier of the user account playing the game */
  accountId: string;
  /** The amount to bet on this coin flip game (minimum 0.01) */
  betAmount: number;
  /** The side of the coin the player is betting on (HEADS or TAILS) */
  choice: PlayCoinFlipDtoChoice;
  /** The type of token being used for the bet (SOL or AFEL) */
  tokenType: PlayCoinFlipDtoTokenType;
  /** Unique reference ID to ensure idempotency of transactions */
  referenceId: string;
}

export type CoinFlipResultDtoChoice = typeof CoinFlipResultDtoChoice[keyof typeof CoinFlipResultDtoChoice];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipResultDtoChoice = {
  HEADS: 'HEADS',
  TAILS: 'TAILS',
} as const;

export type CoinFlipResultDtoResult = typeof CoinFlipResultDtoResult[keyof typeof CoinFlipResultDtoResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipResultDtoResult = {
  HEADS: 'HEADS',
  TAILS: 'TAILS',
} as const;

export type CoinFlipResultDtoTokenType = typeof CoinFlipResultDtoTokenType[keyof typeof CoinFlipResultDtoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipResultDtoTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface CoinFlipResultDto {
  readonly choice: CoinFlipResultDtoChoice;
  readonly result: CoinFlipResultDtoResult;
  readonly won: boolean;
  readonly betAmount: number;
  readonly winAmount: number;
  readonly commission: number;
  readonly balanceBefore: number;
  readonly balanceAfter: number;
  readonly tokenType: CoinFlipResultDtoTokenType;
  readonly transactionId: string;
}

export type CoinFlipHistoryItemResult = typeof CoinFlipHistoryItemResult[keyof typeof CoinFlipHistoryItemResult];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipHistoryItemResult = {
  HEADS: 'HEADS',
  TAILS: 'TAILS',
} as const;

export type CoinFlipHistoryItemChoice = typeof CoinFlipHistoryItemChoice[keyof typeof CoinFlipHistoryItemChoice];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipHistoryItemChoice = {
  HEADS: 'HEADS',
  TAILS: 'TAILS',
} as const;

export type CoinFlipHistoryItemTokenType = typeof CoinFlipHistoryItemTokenType[keyof typeof CoinFlipHistoryItemTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipHistoryItemTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface CoinFlipHistoryItem {
  readonly id: string;
  readonly result: CoinFlipHistoryItemResult;
  readonly choice: CoinFlipHistoryItemChoice;
  readonly betAmount: number;
  readonly winAmount: number;
  readonly won: boolean;
  readonly tokenType: CoinFlipHistoryItemTokenType;
  readonly createdAt: string;
}

export interface CoinFlipHistoryResponse {
  readonly items: readonly CoinFlipHistoryItem[];
  readonly total: number;
  readonly page: number;
  readonly limit: number;
}

export type CoinFlipStatsTokenType = typeof CoinFlipStatsTokenType[keyof typeof CoinFlipStatsTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CoinFlipStatsTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export interface CoinFlipStats {
  readonly totalGames: number;
  readonly wins: number;
  readonly losses: number;
  readonly winRate: number;
  readonly totalBetAmount: number;
  readonly totalWinAmount: number;
  readonly netProfit: number;
  readonly headsCount: number;
  readonly tailsCount: number;
  readonly largestWin: number;
  readonly tokenType: CoinFlipStatsTokenType;
}

export type TransactionControllerGetWalletsHoldingsParams = {
/**
 * Comma-separated wallet addresses
 */
walletAddresses: string;
/**
 * Type of token to get balances for
 */
tokenType: TransactionControllerGetWalletsHoldingsTokenType;
};

export type TransactionControllerGetWalletsHoldingsTokenType = typeof TransactionControllerGetWalletsHoldingsTokenType[keyof typeof TransactionControllerGetWalletsHoldingsTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionControllerGetWalletsHoldingsTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type TransactionControllerGetAvailableBalanceParams = {
/**
 * Account ID to get balance for
 */
accountId: string;
/**
 * Type of token to get balance for
 */
tokenType: TransactionControllerGetAvailableBalanceTokenType;
};

export type TransactionControllerGetAvailableBalanceTokenType = typeof TransactionControllerGetAvailableBalanceTokenType[keyof typeof TransactionControllerGetAvailableBalanceTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionControllerGetAvailableBalanceTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type TransactionControllerGetAvailableBalanceListParams = {
/**
 * Account ID to get balance for
 */
accountId: string;
};

export type TransactionControllerGetActiveBlockagesParams = {
/**
 * Account ID to get balance for
 */
accountId: string;
/**
 * Type of token to get balance for
 */
tokenType: TransactionControllerGetActiveBlockagesTokenType;
};

export type TransactionControllerGetActiveBlockagesTokenType = typeof TransactionControllerGetActiveBlockagesTokenType[keyof typeof TransactionControllerGetActiveBlockagesTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionControllerGetActiveBlockagesTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type TransactionControllerGetBlockageHistoryParams = {
/**
 * Account ID to get balance for
 */
accountId: string;
/**
 * Type of token to get balance for
 */
tokenType: TransactionControllerGetBlockageHistoryTokenType;
/**
 * Number of records to return
 */
limit?: number;
/**
 * Number of records to skip
 */
offset?: number;
};

export type TransactionControllerGetBlockageHistoryTokenType = typeof TransactionControllerGetBlockageHistoryTokenType[keyof typeof TransactionControllerGetBlockageHistoryTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionControllerGetBlockageHistoryTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type NFTStakingControllerGetLeaderboardParams = {
/**
 * Number of entries to return
 */
limit?: number;
/**
 * Number of entries to skip
 */
offset?: number;
};

export type NFTCollectionControllerGetNFTsParams = {
/**
 * Page number
 */
page?: number;
/**
 * Number of NFTs per page
 */
limit?: number;
/**
 * Sort direction
 */
sort?: NFTCollectionControllerGetNFTsSort;
/**
 * NFT trait type
 */
trait_type: NFTCollectionControllerGetNFTsTraitType;
/**
 * Trait value
 */
value: string;
};

export type NFTCollectionControllerGetNFTsSort = typeof NFTCollectionControllerGetNFTsSort[keyof typeof NFTCollectionControllerGetNFTsSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NFTCollectionControllerGetNFTsSort = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type NFTCollectionControllerGetNFTsTraitType = typeof NFTCollectionControllerGetNFTsTraitType[keyof typeof NFTCollectionControllerGetNFTsTraitType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NFTCollectionControllerGetNFTsTraitType = {
  Background: 'Background',
  Clothes: 'Clothes',
  Head: 'Head',
  Eye: 'Eye',
  Skin: 'Skin',
  Mouth: 'Mouth',
} as const;

export type GamesControllerGetBalanceParams = {
/**
 * The user account ID to get balance for
 */
accountId: string;
/**
 * The type of token to get balance for (SOL or AFEL)
 */
tokenType: GamesControllerGetBalanceTokenType;
};

export type GamesControllerGetBalanceTokenType = typeof GamesControllerGetBalanceTokenType[keyof typeof GamesControllerGetBalanceTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GamesControllerGetBalanceTokenType = {
  SOL: 'SOL',
  WAA: 'WAA',
  AFEL: 'AFEL',
  USDC: 'USDC',
} as const;

export type GamesControllerGetAllBalancesParams = {
/**
 * The user account ID to get balances for
 */
accountId: string;
};

export type SlotMachineControllerGetHistoryParams = {
accountId: string;
page: number;
limit: number;
};

export type SlotMachineControllerGetStatsParams = {
accountId: string;
tokenType: string;
};

export type CoinFlipControllerGetHistoryParams = {
accountId: string;
page: number;
limit: number;
};

export type CoinFlipControllerGetStatsParams = {
accountId: string;
tokenType: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const appControllerGetHello = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/`, method: 'GET', signal
    },
      options);
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: QueryKey }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown



export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const s3ControllerListBuckets = (
    s3Request: S3Request,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/s3/list/buckets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: s3Request, signal
    },
      options);
    }
  


export const getS3ControllerListBucketsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerListBuckets>>, TError,{data: S3Request}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof s3ControllerListBuckets>>, TError,{data: S3Request}, TContext> => {

const mutationKey = ['s3ControllerListBuckets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof s3ControllerListBuckets>>, {data: S3Request}> = (props) => {
          const {data} = props ?? {};

          return  s3ControllerListBuckets(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type S3ControllerListBucketsMutationResult = NonNullable<Awaited<ReturnType<typeof s3ControllerListBuckets>>>
    export type S3ControllerListBucketsMutationBody = S3Request
    export type S3ControllerListBucketsMutationError = unknown

    export const useS3ControllerListBuckets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerListBuckets>>, TError,{data: S3Request}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof s3ControllerListBuckets>>,
        TError,
        {data: S3Request},
        TContext
      > => {

      const mutationOptions = getS3ControllerListBucketsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const s3ControllerGetFile = (
    fileRequest: FileRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/s3/list/file`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fileRequest, signal
    },
      options);
    }
  


export const getS3ControllerGetFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerGetFile>>, TError,{data: FileRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof s3ControllerGetFile>>, TError,{data: FileRequest}, TContext> => {

const mutationKey = ['s3ControllerGetFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof s3ControllerGetFile>>, {data: FileRequest}> = (props) => {
          const {data} = props ?? {};

          return  s3ControllerGetFile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type S3ControllerGetFileMutationResult = NonNullable<Awaited<ReturnType<typeof s3ControllerGetFile>>>
    export type S3ControllerGetFileMutationBody = FileRequest
    export type S3ControllerGetFileMutationError = unknown

    export const useS3ControllerGetFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerGetFile>>, TError,{data: FileRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof s3ControllerGetFile>>,
        TError,
        {data: FileRequest},
        TContext
      > => {

      const mutationOptions = getS3ControllerGetFileMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const s3ControllerUploadFile = (
    fileRequest: FileRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/s3/upload/file`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: fileRequest, signal
    },
      options);
    }
  


export const getS3ControllerUploadFileMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerUploadFile>>, TError,{data: FileRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof s3ControllerUploadFile>>, TError,{data: FileRequest}, TContext> => {

const mutationKey = ['s3ControllerUploadFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof s3ControllerUploadFile>>, {data: FileRequest}> = (props) => {
          const {data} = props ?? {};

          return  s3ControllerUploadFile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type S3ControllerUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof s3ControllerUploadFile>>>
    export type S3ControllerUploadFileMutationBody = FileRequest
    export type S3ControllerUploadFileMutationError = unknown

    export const useS3ControllerUploadFile = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof s3ControllerUploadFile>>, TError,{data: FileRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof s3ControllerUploadFile>>,
        TError,
        {data: FileRequest},
        TContext
      > => {

      const mutationOptions = getS3ControllerUploadFileMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const referanceControllerGetAccountReferralCode = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<string>(
      {url: `/referals/code`, method: 'GET', signal
    },
      options);
    }
  

export const getReferanceControllerGetAccountReferralCodeQueryKey = () => {
    return [`/referals/code`] as const;
    }

    
export const getReferanceControllerGetAccountReferralCodeQueryOptions = <TData = Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReferanceControllerGetAccountReferralCodeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>> = ({ signal }) => referanceControllerGetAccountReferralCode(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>, TError, TData> & { queryKey: QueryKey }
}

export type ReferanceControllerGetAccountReferralCodeQueryResult = NonNullable<Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>>
export type ReferanceControllerGetAccountReferralCodeQueryError = unknown



export function useReferanceControllerGetAccountReferralCode<TData = Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetAccountReferralCode>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getReferanceControllerGetAccountReferralCodeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const referanceControllerUseReferanceCode = (
    useReferralCodeRequest: UseReferralCodeRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/referals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: useReferralCodeRequest, signal
    },
      options);
    }
  


export const getReferanceControllerUseReferanceCodeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>, TError,{data: UseReferralCodeRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>, TError,{data: UseReferralCodeRequest}, TContext> => {

const mutationKey = ['referanceControllerUseReferanceCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>, {data: UseReferralCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  referanceControllerUseReferanceCode(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReferanceControllerUseReferanceCodeMutationResult = NonNullable<Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>>
    export type ReferanceControllerUseReferanceCodeMutationBody = UseReferralCodeRequest
    export type ReferanceControllerUseReferanceCodeMutationError = unknown

    export const useReferanceControllerUseReferanceCode = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>, TError,{data: UseReferralCodeRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof referanceControllerUseReferanceCode>>,
        TError,
        {data: UseReferralCodeRequest},
        TContext
      > => {

      const mutationOptions = getReferanceControllerUseReferanceCodeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const referanceControllerGetReferanceRelations = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<GetAccountReferralRelationsDto>(
      {url: `/referals/relations`, method: 'GET', signal
    },
      options);
    }
  

export const getReferanceControllerGetReferanceRelationsQueryKey = () => {
    return [`/referals/relations`] as const;
    }

    
export const getReferanceControllerGetReferanceRelationsQueryOptions = <TData = Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReferanceControllerGetReferanceRelationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>> = ({ signal }) => referanceControllerGetReferanceRelations(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>, TError, TData> & { queryKey: QueryKey }
}

export type ReferanceControllerGetReferanceRelationsQueryResult = NonNullable<Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>>
export type ReferanceControllerGetReferanceRelationsQueryError = unknown



export function useReferanceControllerGetReferanceRelations<TData = Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof referanceControllerGetReferanceRelations>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getReferanceControllerGetReferanceRelationsQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves token balances for a list of wallet addresses for specified token type
 * @summary Get token balances for multiple wallets
 */
export const transactionControllerGetWalletsHoldings = (
    params: TransactionControllerGetWalletsHoldingsParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<unknown>(
      {url: `/transactions/wallets/holdings`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTransactionControllerGetWalletsHoldingsQueryKey = (params: TransactionControllerGetWalletsHoldingsParams,) => {
    return [`/transactions/wallets/holdings`, ...(params ? [params]: [])] as const;
    }

    
export const getTransactionControllerGetWalletsHoldingsQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>, TError = void>(params: TransactionControllerGetWalletsHoldingsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetWalletsHoldingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>> = ({ signal }) => transactionControllerGetWalletsHoldings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetWalletsHoldingsQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>>
export type TransactionControllerGetWalletsHoldingsQueryError = void


/**
 * @summary Get token balances for multiple wallets
 */

export function useTransactionControllerGetWalletsHoldings<TData = Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>, TError = void>(
 params: TransactionControllerGetWalletsHoldingsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetWalletsHoldings>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetWalletsHoldingsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get application wallet address
 */
export const transactionControllerGetApplicationWalletAddress = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<string>(
      {url: `/transactions/application/wallet/address`, method: 'GET', signal
    },
      options);
    }
  

export const getTransactionControllerGetApplicationWalletAddressQueryKey = () => {
    return [`/transactions/application/wallet/address`] as const;
    }

    
export const getTransactionControllerGetApplicationWalletAddressQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetApplicationWalletAddressQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>> = ({ signal }) => transactionControllerGetApplicationWalletAddress(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetApplicationWalletAddressQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>>
export type TransactionControllerGetApplicationWalletAddressQueryError = unknown


/**
 * @summary Get application wallet address
 */

export function useTransactionControllerGetApplicationWalletAddress<TData = Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetApplicationWalletAddress>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetApplicationWalletAddressQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get available balance
 */
export const transactionControllerGetAvailableBalance = (
    params: TransactionControllerGetAvailableBalanceParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BalanceResponse>(
      {url: `/transactions/user/balance`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTransactionControllerGetAvailableBalanceQueryKey = (params: TransactionControllerGetAvailableBalanceParams,) => {
    return [`/transactions/user/balance`, ...(params ? [params]: [])] as const;
    }

    
export const getTransactionControllerGetAvailableBalanceQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>, TError = unknown>(params: TransactionControllerGetAvailableBalanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetAvailableBalanceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>> = ({ signal }) => transactionControllerGetAvailableBalance(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetAvailableBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>>
export type TransactionControllerGetAvailableBalanceQueryError = unknown


/**
 * @summary Get available balance
 */

export function useTransactionControllerGetAvailableBalance<TData = Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>, TError = unknown>(
 params: TransactionControllerGetAvailableBalanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalance>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetAvailableBalanceQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get available balance
 */
export const transactionControllerGetAvailableBalanceList = (
    params: TransactionControllerGetAvailableBalanceListParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BalanceResponse[]>(
      {url: `/transactions/user/balance/list`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTransactionControllerGetAvailableBalanceListQueryKey = (params: TransactionControllerGetAvailableBalanceListParams,) => {
    return [`/transactions/user/balance/list`, ...(params ? [params]: [])] as const;
    }

    
export const getTransactionControllerGetAvailableBalanceListQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>, TError = unknown>(params: TransactionControllerGetAvailableBalanceListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetAvailableBalanceListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>> = ({ signal }) => transactionControllerGetAvailableBalanceList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetAvailableBalanceListQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>>
export type TransactionControllerGetAvailableBalanceListQueryError = unknown


/**
 * @summary Get available balance
 */

export function useTransactionControllerGetAvailableBalanceList<TData = Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>, TError = unknown>(
 params: TransactionControllerGetAvailableBalanceListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetAvailableBalanceList>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetAvailableBalanceListQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Process a wallet deposit transaction
 */
export const transactionControllerWalletDeposit = (
    walletDepositRequest: WalletDepositRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WalletDepositResponse>(
      {url: `/transactions/deposit/wallet`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: walletDepositRequest, signal
    },
      options);
    }
  


export const getTransactionControllerWalletDepositMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWalletDeposit>>, TError,{data: WalletDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWalletDeposit>>, TError,{data: WalletDepositRequest}, TContext> => {

const mutationKey = ['transactionControllerWalletDeposit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerWalletDeposit>>, {data: WalletDepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerWalletDeposit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerWalletDepositMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerWalletDeposit>>>
    export type TransactionControllerWalletDepositMutationBody = WalletDepositRequest
    export type TransactionControllerWalletDepositMutationError = void

    /**
 * @summary Process a wallet deposit transaction
 */
export const useTransactionControllerWalletDeposit = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWalletDeposit>>, TError,{data: WalletDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerWalletDeposit>>,
        TError,
        {data: WalletDepositRequest},
        TContext
      > => {

      const mutationOptions = getTransactionControllerWalletDepositMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Process a prize deposit transaction, Only TOKEN prize
 */
export const transactionControllerPrizeDeposit = (
    prizeDepositRequest: PrizeDepositRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<PrizeDepositResponse>(
      {url: `/transactions/deposit/prize/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: prizeDepositRequest, signal
    },
      options);
    }
  


export const getTransactionControllerPrizeDepositMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>, TError,{data: PrizeDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>, TError,{data: PrizeDepositRequest}, TContext> => {

const mutationKey = ['transactionControllerPrizeDeposit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>, {data: PrizeDepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerPrizeDeposit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerPrizeDepositMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>>
    export type TransactionControllerPrizeDepositMutationBody = PrizeDepositRequest
    export type TransactionControllerPrizeDepositMutationError = void

    /**
 * @summary Process a prize deposit transaction, Only TOKEN prize
 */
export const useTransactionControllerPrizeDeposit = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>, TError,{data: PrizeDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerPrizeDeposit>>,
        TError,
        {data: PrizeDepositRequest},
        TContext
      > => {

      const mutationOptions = getTransactionControllerPrizeDepositMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Process a game deposit transaction
 */
export const transactionControllerGameDeposit = (
    gameDepositRequest: GameDepositRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<GameDepositResponse>(
      {url: `/transactions/deposit/game`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: gameDepositRequest, signal
    },
      options);
    }
  


export const getTransactionControllerGameDepositMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerGameDeposit>>, TError,{data: GameDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerGameDeposit>>, TError,{data: GameDepositRequest}, TContext> => {

const mutationKey = ['transactionControllerGameDeposit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerGameDeposit>>, {data: GameDepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerGameDeposit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerGameDepositMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGameDeposit>>>
    export type TransactionControllerGameDepositMutationBody = GameDepositRequest
    export type TransactionControllerGameDepositMutationError = void

    /**
 * @summary Process a game deposit transaction
 */
export const useTransactionControllerGameDeposit = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerGameDeposit>>, TError,{data: GameDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerGameDeposit>>,
        TError,
        {data: GameDepositRequest},
        TContext
      > => {

      const mutationOptions = getTransactionControllerGameDepositMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Process a withdrawal transaction
 */
export const transactionControllerWithdraw = (
    withdrawRequestDto: WithdrawRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WithdrawResponse>(
      {url: `/transactions/withdraw`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: withdrawRequestDto, signal
    },
      options);
    }
  


export const getTransactionControllerWithdrawMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWithdraw>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWithdraw>>, TError,{data: WithdrawRequestDto}, TContext> => {

const mutationKey = ['transactionControllerWithdraw'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerWithdraw>>, {data: WithdrawRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerWithdraw(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerWithdrawMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerWithdraw>>>
    export type TransactionControllerWithdrawMutationBody = WithdrawRequestDto
    export type TransactionControllerWithdrawMutationError = void

    /**
 * @summary Process a withdrawal transaction
 */
export const useTransactionControllerWithdraw = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerWithdraw>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerWithdraw>>,
        TError,
        {data: WithdrawRequestDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerWithdrawMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Add a new blockage
 */
export const transactionControllerAddBlockage = (
    addBlockageDto: AddBlockageDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<AddBlockageResponse | void>(
      {url: `/transactions/blockages/add`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addBlockageDto, signal
    },
      options);
    }
  


export const getTransactionControllerAddBlockageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerAddBlockage>>, TError,{data: AddBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerAddBlockage>>, TError,{data: AddBlockageDto}, TContext> => {

const mutationKey = ['transactionControllerAddBlockage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerAddBlockage>>, {data: AddBlockageDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerAddBlockage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerAddBlockageMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerAddBlockage>>>
    export type TransactionControllerAddBlockageMutationBody = AddBlockageDto
    export type TransactionControllerAddBlockageMutationError = void

    /**
 * @summary Add a new blockage
 */
export const useTransactionControllerAddBlockage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerAddBlockage>>, TError,{data: AddBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerAddBlockage>>,
        TError,
        {data: AddBlockageDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerAddBlockageMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Remove a single blockage
 */
export const transactionControllerRemoveBlockage = (
    removeBlockageDto: RemoveBlockageDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<RemoveBlockageResponse | void>(
      {url: `/transactions/blockages/remove`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: removeBlockageDto, signal
    },
      options);
    }
  


export const getTransactionControllerRemoveBlockageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>, TError,{data: RemoveBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>, TError,{data: RemoveBlockageDto}, TContext> => {

const mutationKey = ['transactionControllerRemoveBlockage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>, {data: RemoveBlockageDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerRemoveBlockage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerRemoveBlockageMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>>
    export type TransactionControllerRemoveBlockageMutationBody = RemoveBlockageDto
    export type TransactionControllerRemoveBlockageMutationError = void

    /**
 * @summary Remove a single blockage
 */
export const useTransactionControllerRemoveBlockage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>, TError,{data: RemoveBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerRemoveBlockage>>,
        TError,
        {data: RemoveBlockageDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerRemoveBlockageMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Remove multiple blockages
 */
export const transactionControllerRemoveMultipleBlockages = (
    removeMultipleBlockagesDto: RemoveMultipleBlockagesDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<RemoveMultipleBlockagesResponseDto>(
      {url: `/transactions/blockages/remove/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: removeMultipleBlockagesDto, signal
    },
      options);
    }
  


export const getTransactionControllerRemoveMultipleBlockagesMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>, TError,{data: RemoveMultipleBlockagesDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>, TError,{data: RemoveMultipleBlockagesDto}, TContext> => {

const mutationKey = ['transactionControllerRemoveMultipleBlockages'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>, {data: RemoveMultipleBlockagesDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerRemoveMultipleBlockages(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerRemoveMultipleBlockagesMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>>
    export type TransactionControllerRemoveMultipleBlockagesMutationBody = RemoveMultipleBlockagesDto
    export type TransactionControllerRemoveMultipleBlockagesMutationError = void

    /**
 * @summary Remove multiple blockages
 */
export const useTransactionControllerRemoveMultipleBlockages = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>, TError,{data: RemoveMultipleBlockagesDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerRemoveMultipleBlockages>>,
        TError,
        {data: RemoveMultipleBlockagesDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerRemoveMultipleBlockagesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary List active blockages
 */
export const transactionControllerGetActiveBlockages = (
    params: TransactionControllerGetActiveBlockagesParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<ActiveBlockagesResponseDto>(
      {url: `/transactions/user/blockages/list/active`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTransactionControllerGetActiveBlockagesQueryKey = (params: TransactionControllerGetActiveBlockagesParams,) => {
    return [`/transactions/user/blockages/list/active`, ...(params ? [params]: [])] as const;
    }

    
export const getTransactionControllerGetActiveBlockagesQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>, TError = unknown>(params: TransactionControllerGetActiveBlockagesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetActiveBlockagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>> = ({ signal }) => transactionControllerGetActiveBlockages(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetActiveBlockagesQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>>
export type TransactionControllerGetActiveBlockagesQueryError = unknown


/**
 * @summary List active blockages
 */

export function useTransactionControllerGetActiveBlockages<TData = Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>, TError = unknown>(
 params: TransactionControllerGetActiveBlockagesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetActiveBlockages>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetActiveBlockagesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get blockage history
 */
export const transactionControllerGetBlockageHistory = (
    params: TransactionControllerGetBlockageHistoryParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BlockageHistoryResponseDto>(
      {url: `/transactions/user/blockages/list/history`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTransactionControllerGetBlockageHistoryQueryKey = (params: TransactionControllerGetBlockageHistoryParams,) => {
    return [`/transactions/user/blockages/list/history`, ...(params ? [params]: [])] as const;
    }

    
export const getTransactionControllerGetBlockageHistoryQueryOptions = <TData = Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>, TError = unknown>(params: TransactionControllerGetBlockageHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionControllerGetBlockageHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>> = ({ signal }) => transactionControllerGetBlockageHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type TransactionControllerGetBlockageHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>>
export type TransactionControllerGetBlockageHistoryQueryError = unknown


/**
 * @summary Get blockage history
 */

export function useTransactionControllerGetBlockageHistory<TData = Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>, TError = unknown>(
 params: TransactionControllerGetBlockageHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetBlockageHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTransactionControllerGetBlockageHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Burn a blockage (Game exit scenario)
 */
export const transactionControllerBurnBlockage = (
    burnBlockageDto: BurnBlockageDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BurnBlockageResponse | void>(
      {url: `/transactions/blockages/burn`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: burnBlockageDto, signal
    },
      options);
    }
  


export const getTransactionControllerBurnBlockageMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerBurnBlockage>>, TError,{data: BurnBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof transactionControllerBurnBlockage>>, TError,{data: BurnBlockageDto}, TContext> => {

const mutationKey = ['transactionControllerBurnBlockage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transactionControllerBurnBlockage>>, {data: BurnBlockageDto}> = (props) => {
          const {data} = props ?? {};

          return  transactionControllerBurnBlockage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TransactionControllerBurnBlockageMutationResult = NonNullable<Awaited<ReturnType<typeof transactionControllerBurnBlockage>>>
    export type TransactionControllerBurnBlockageMutationBody = BurnBlockageDto
    export type TransactionControllerBurnBlockageMutationError = void

    /**
 * @summary Burn a blockage (Game exit scenario)
 */
export const useTransactionControllerBurnBlockage = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transactionControllerBurnBlockage>>, TError,{data: BurnBlockageDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof transactionControllerBurnBlockage>>,
        TError,
        {data: BurnBlockageDto},
        TContext
      > => {

      const mutationOptions = getTransactionControllerBurnBlockageMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get user NFTs
 */
export const nFTStakingControllerGetUserNFTs = (
    walletAddress: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<NFTMetadataDto[]>(
      {url: `/nft-staking/nfts/${walletAddress}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTStakingControllerGetUserNFTsQueryKey = (walletAddress: string,) => {
    return [`/nft-staking/nfts/${walletAddress}`] as const;
    }

    
export const getNFTStakingControllerGetUserNFTsQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>, TError = void>(walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetUserNFTsQueryKey(walletAddress);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>> = ({ signal }) => nFTStakingControllerGetUserNFTs(walletAddress, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletAddress), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetUserNFTsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>>
export type NFTStakingControllerGetUserNFTsQueryError = void


/**
 * @summary Get user NFTs
 */

export function useNFTStakingControllerGetUserNFTs<TData = Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>, TError = void>(
 walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetUserNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetUserNFTsQueryOptions(walletAddress,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create freeze transactions for NFTs
 */
export const nFTStakingControllerFreezeNFTs = (
    freezeNFTsRequestDto: FreezeNFTsRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<TransactionResponseDto>(
      {url: `/nft-staking/freeze-nfts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: freezeNFTsRequestDto, signal
    },
      options);
    }
  


export const getNFTStakingControllerFreezeNFTsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext> => {

const mutationKey = ['nFTStakingControllerFreezeNFTs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>, {data: FreezeNFTsRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  nFTStakingControllerFreezeNFTs(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NFTStakingControllerFreezeNFTsMutationResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>>
    export type NFTStakingControllerFreezeNFTsMutationBody = FreezeNFTsRequestDto
    export type NFTStakingControllerFreezeNFTsMutationError = void

    /**
 * @summary Create freeze transactions for NFTs
 */
export const useNFTStakingControllerFreezeNFTs = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof nFTStakingControllerFreezeNFTs>>,
        TError,
        {data: FreezeNFTsRequestDto},
        TContext
      > => {

      const mutationOptions = getNFTStakingControllerFreezeNFTsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Create thaw transactions for NFTs
 */
export const nFTStakingControllerThawNFTs = (
    freezeNFTsRequestDto: FreezeNFTsRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<TransactionResponseDto>(
      {url: `/nft-staking/thaw-nfts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: freezeNFTsRequestDto, signal
    },
      options);
    }
  


export const getNFTStakingControllerThawNFTsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext> => {

const mutationKey = ['nFTStakingControllerThawNFTs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>, {data: FreezeNFTsRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  nFTStakingControllerThawNFTs(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NFTStakingControllerThawNFTsMutationResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>>
    export type NFTStakingControllerThawNFTsMutationBody = FreezeNFTsRequestDto
    export type NFTStakingControllerThawNFTsMutationError = void

    /**
 * @summary Create thaw transactions for NFTs
 */
export const useNFTStakingControllerThawNFTs = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>, TError,{data: FreezeNFTsRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof nFTStakingControllerThawNFTs>>,
        TError,
        {data: FreezeNFTsRequestDto},
        TContext
      > => {

      const mutationOptions = getNFTStakingControllerThawNFTsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Finalize signed transaction
 */
export const nFTStakingControllerFinalizeTransaction = (
    finalizeTransactionRequestDto: FinalizeTransactionRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<TransactionSignatureDto>(
      {url: `/nft-staking/finalize-transaction`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: finalizeTransactionRequestDto, signal
    },
      options);
    }
  


export const getNFTStakingControllerFinalizeTransactionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>, TError,{data: FinalizeTransactionRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>, TError,{data: FinalizeTransactionRequestDto}, TContext> => {

const mutationKey = ['nFTStakingControllerFinalizeTransaction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>, {data: FinalizeTransactionRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  nFTStakingControllerFinalizeTransaction(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type NFTStakingControllerFinalizeTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>>
    export type NFTStakingControllerFinalizeTransactionMutationBody = FinalizeTransactionRequestDto
    export type NFTStakingControllerFinalizeTransactionMutationError = void

    /**
 * @summary Finalize signed transaction
 */
export const useNFTStakingControllerFinalizeTransaction = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>, TError,{data: FinalizeTransactionRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof nFTStakingControllerFinalizeTransaction>>,
        TError,
        {data: FinalizeTransactionRequestDto},
        TContext
      > => {

      const mutationOptions = getNFTStakingControllerFinalizeTransactionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get wallet staking statistics
 */
export const nFTStakingControllerGetWalletStats = (
    walletAddress: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WalletStatsDto>(
      {url: `/nft-staking/wallet-stats/${walletAddress}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTStakingControllerGetWalletStatsQueryKey = (walletAddress: string,) => {
    return [`/nft-staking/wallet-stats/${walletAddress}`] as const;
    }

    
export const getNFTStakingControllerGetWalletStatsQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>, TError = void>(walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetWalletStatsQueryKey(walletAddress);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>> = ({ signal }) => nFTStakingControllerGetWalletStats(walletAddress, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletAddress), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetWalletStatsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>>
export type NFTStakingControllerGetWalletStatsQueryError = void


/**
 * @summary Get wallet staking statistics
 */

export function useNFTStakingControllerGetWalletStats<TData = Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>, TError = void>(
 walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetWalletStatsQueryOptions(walletAddress,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get staked NFTs for wallet
 */
export const nFTStakingControllerGetStakedNFTs = (
    walletAddress: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<StakedNFTDto[]>(
      {url: `/nft-staking/staked-nfts/${walletAddress}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTStakingControllerGetStakedNFTsQueryKey = (walletAddress: string,) => {
    return [`/nft-staking/staked-nfts/${walletAddress}`] as const;
    }

    
export const getNFTStakingControllerGetStakedNFTsQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>, TError = void>(walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetStakedNFTsQueryKey(walletAddress);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>> = ({ signal }) => nFTStakingControllerGetStakedNFTs(walletAddress, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletAddress), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetStakedNFTsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>>
export type NFTStakingControllerGetStakedNFTsQueryError = void


/**
 * @summary Get staked NFTs for wallet
 */

export function useNFTStakingControllerGetStakedNFTs<TData = Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>, TError = void>(
 walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetStakedNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetStakedNFTsQueryOptions(walletAddress,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get wallet points
 */
export const nFTStakingControllerGetWalletPoints = (
    walletAddress: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WalletPointsDto>(
      {url: `/nft-staking/wallet-points/${walletAddress}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTStakingControllerGetWalletPointsQueryKey = (walletAddress: string,) => {
    return [`/nft-staking/wallet-points/${walletAddress}`] as const;
    }

    
export const getNFTStakingControllerGetWalletPointsQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>, TError = void>(walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetWalletPointsQueryKey(walletAddress);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>> = ({ signal }) => nFTStakingControllerGetWalletPoints(walletAddress, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletAddress), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetWalletPointsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>>
export type NFTStakingControllerGetWalletPointsQueryError = void


/**
 * @summary Get wallet points
 */

export function useNFTStakingControllerGetWalletPoints<TData = Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>, TError = void>(
 walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetWalletPoints>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetWalletPointsQueryOptions(walletAddress,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get staking leaderboard
 */
export const nFTStakingControllerGetLeaderboard = (
    params?: NFTStakingControllerGetLeaderboardParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<LeaderboardResponseDto>(
      {url: `/nft-staking/leaderboard`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getNFTStakingControllerGetLeaderboardQueryKey = (params?: NFTStakingControllerGetLeaderboardParams,) => {
    return [`/nft-staking/leaderboard`, ...(params ? [params]: [])] as const;
    }

    
export const getNFTStakingControllerGetLeaderboardQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>, TError = unknown>(params?: NFTStakingControllerGetLeaderboardParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetLeaderboardQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>> = ({ signal }) => nFTStakingControllerGetLeaderboard(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetLeaderboardQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>>
export type NFTStakingControllerGetLeaderboardQueryError = unknown


/**
 * @summary Get staking leaderboard
 */

export function useNFTStakingControllerGetLeaderboard<TData = Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>, TError = unknown>(
 params?: NFTStakingControllerGetLeaderboardParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetLeaderboard>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetLeaderboardQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get transaction status
 */
export const nFTStakingControllerGetTransactionStatus = (
    signature: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<TransactionStatusDto>(
      {url: `/nft-staking/transaction/${signature}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTStakingControllerGetTransactionStatusQueryKey = (signature: string,) => {
    return [`/nft-staking/transaction/${signature}`] as const;
    }

    
export const getNFTStakingControllerGetTransactionStatusQueryOptions = <TData = Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>, TError = void>(signature: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTStakingControllerGetTransactionStatusQueryKey(signature);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>> = ({ signal }) => nFTStakingControllerGetTransactionStatus(signature, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(signature), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTStakingControllerGetTransactionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>>
export type NFTStakingControllerGetTransactionStatusQueryError = void


/**
 * @summary Get transaction status
 */

export function useNFTStakingControllerGetTransactionStatus<TData = Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>, TError = void>(
 signature: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTStakingControllerGetTransactionStatus>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTStakingControllerGetTransactionStatusQueryOptions(signature,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Queries Magic Eden activities for the specified wallet (walletAddress). If any NFTs from the target collection were purchased and not already recorded, a new ticket record is created. Returns the user‚Äôs and the system‚Äôs total raffle ticket counts.
 * @summary Check wallet‚Äôs NFT purchases and assign raffle tickets.
 */
export const nFTRaffleControllerCheckUserTickets = (
    walletAddress: string,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<CheckTickerResponse>(
      {url: `/nft-raffles/check-ticker/${walletAddress}`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTRaffleControllerCheckUserTicketsQueryKey = (walletAddress: string,) => {
    return [`/nft-raffles/check-ticker/${walletAddress}`] as const;
    }

    
export const getNFTRaffleControllerCheckUserTicketsQueryOptions = <TData = Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>, TError = unknown>(walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTRaffleControllerCheckUserTicketsQueryKey(walletAddress);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>> = ({ signal }) => nFTRaffleControllerCheckUserTickets(walletAddress, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletAddress), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTRaffleControllerCheckUserTicketsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>>
export type NFTRaffleControllerCheckUserTicketsQueryError = unknown


/**
 * @summary Check wallet‚Äôs NFT purchases and assign raffle tickets.
 */

export function useNFTRaffleControllerCheckUserTickets<TData = Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>, TError = unknown>(
 walletAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTRaffleControllerCheckUserTickets>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTRaffleControllerCheckUserTicketsQueryOptions(walletAddress,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const marketPlaceControllerHandleWebhook = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/market-place/webhook`, method: 'POST', signal
    },
      options);
    }
  


export const getMarketPlaceControllerHandleWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>, TError,void, TContext> => {

const mutationKey = ['marketPlaceControllerHandleWebhook'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>, void> = () => {
          

          return  marketPlaceControllerHandleWebhook(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketPlaceControllerHandleWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>>
    
    export type MarketPlaceControllerHandleWebhookMutationError = unknown

    export const useMarketPlaceControllerHandleWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof marketPlaceControllerHandleWebhook>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getMarketPlaceControllerHandleWebhookMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns NFTs based on trait filters with pagination support.
 * @summary Get filtered NFTs with pagination
 */
export const nFTCollectionControllerGetNFTs = (
    params: NFTCollectionControllerGetNFTsParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<PaginatedResponseDto>(
      {url: `/nft-collection`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getNFTCollectionControllerGetNFTsQueryKey = (params: NFTCollectionControllerGetNFTsParams,) => {
    return [`/nft-collection`, ...(params ? [params]: [])] as const;
    }

    
export const getNFTCollectionControllerGetNFTsQueryOptions = <TData = Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>, TError = unknown>(params: NFTCollectionControllerGetNFTsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTCollectionControllerGetNFTsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>> = ({ signal }) => nFTCollectionControllerGetNFTs(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTCollectionControllerGetNFTsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>>
export type NFTCollectionControllerGetNFTsQueryError = unknown


/**
 * @summary Get filtered NFTs with pagination
 */

export function useNFTCollectionControllerGetNFTs<TData = Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>, TError = unknown>(
 params: NFTCollectionControllerGetNFTsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetNFTs>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTCollectionControllerGetNFTsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns all trait types and their possible values that can be used for filtering
 * @summary Get all available trait types and their possible values
 */
export const nFTCollectionControllerGetAvailableTraits = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<unknown>(
      {url: `/nft-collection/traits`, method: 'GET', signal
    },
      options);
    }
  

export const getNFTCollectionControllerGetAvailableTraitsQueryKey = () => {
    return [`/nft-collection/traits`] as const;
    }

    
export const getNFTCollectionControllerGetAvailableTraitsQueryOptions = <TData = Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNFTCollectionControllerGetAvailableTraitsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>> = ({ signal }) => nFTCollectionControllerGetAvailableTraits(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>, TError, TData> & { queryKey: QueryKey }
}

export type NFTCollectionControllerGetAvailableTraitsQueryResult = NonNullable<Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>>
export type NFTCollectionControllerGetAvailableTraitsQueryError = unknown


/**
 * @summary Get all available trait types and their possible values
 */

export function useNFTCollectionControllerGetAvailableTraits<TData = Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nFTCollectionControllerGetAvailableTraits>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNFTCollectionControllerGetAvailableTraitsQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tokenGateControllerGetUserStatus = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<AccountTokenStatusResponse>(
      {url: `/tokens/status`, method: 'GET', signal
    },
      options);
    }
  

export const getTokenGateControllerGetUserStatusQueryKey = () => {
    return [`/tokens/status`] as const;
    }

    
export const getTokenGateControllerGetUserStatusQueryOptions = <TData = Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTokenGateControllerGetUserStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>> = ({ signal }) => tokenGateControllerGetUserStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type TokenGateControllerGetUserStatusQueryResult = NonNullable<Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>>
export type TokenGateControllerGetUserStatusQueryError = unknown



export function useTokenGateControllerGetUserStatus<TData = Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof tokenGateControllerGetUserStatus>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTokenGateControllerGetUserStatusQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tokenGateControllerSyncTokenGate = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<void>(
      {url: `/tokens/sync`, method: 'POST', signal
    },
      options);
    }
  


export const getTokenGateControllerSyncTokenGateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>, TError,void, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>, TError,void, TContext> => {

const mutationKey = ['tokenGateControllerSyncTokenGate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>, void> = () => {
          

          return  tokenGateControllerSyncTokenGate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokenGateControllerSyncTokenGateMutationResult = NonNullable<Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>>
    
    export type TokenGateControllerSyncTokenGateMutationError = unknown

    export const useTokenGateControllerSyncTokenGate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>, TError,void, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof tokenGateControllerSyncTokenGate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getTokenGateControllerSyncTokenGateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns the wallet address that users need to send funds to when depositing for games. This is the centralized wallet that receives all game deposits.
 * @summary Get game wallet address
 */
export const gamesControllerGetGameWalletAddress = (
    
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<string>(
      {url: `/games/wallet/address`, method: 'GET', signal
    },
      options);
    }
  

export const getGamesControllerGetGameWalletAddressQueryKey = () => {
    return [`/games/wallet/address`] as const;
    }

    
export const getGamesControllerGetGameWalletAddressQueryOptions = <TData = Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>, TError = void>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGamesControllerGetGameWalletAddressQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>> = ({ signal }) => gamesControllerGetGameWalletAddress(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>, TError, TData> & { queryKey: QueryKey }
}

export type GamesControllerGetGameWalletAddressQueryResult = NonNullable<Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>>
export type GamesControllerGetGameWalletAddressQueryError = void


/**
 * @summary Get game wallet address
 */

export function useGamesControllerGetGameWalletAddress<TData = Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>, TError = void>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetGameWalletAddress>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGamesControllerGetGameWalletAddressQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the user's available balance for the specified token type. The response includes total balance, available balance (total minus blockages), any active blockages, and details about each blockage. This endpoint is useful for showing users how much they can wager on games.
 * @summary Get user balance for games
 */
export const gamesControllerGetBalance = (
    params: GamesControllerGetBalanceParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BalanceResponse>(
      {url: `/games/balance`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGamesControllerGetBalanceQueryKey = (params: GamesControllerGetBalanceParams,) => {
    return [`/games/balance`, ...(params ? [params]: [])] as const;
    }

    
export const getGamesControllerGetBalanceQueryOptions = <TData = Awaited<ReturnType<typeof gamesControllerGetBalance>>, TError = void>(params: GamesControllerGetBalanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetBalance>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGamesControllerGetBalanceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gamesControllerGetBalance>>> = ({ signal }) => gamesControllerGetBalance(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetBalance>>, TError, TData> & { queryKey: QueryKey }
}

export type GamesControllerGetBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof gamesControllerGetBalance>>>
export type GamesControllerGetBalanceQueryError = void


/**
 * @summary Get user balance for games
 */

export function useGamesControllerGetBalance<TData = Awaited<ReturnType<typeof gamesControllerGetBalance>>, TError = void>(
 params: GamesControllerGetBalanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetBalance>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGamesControllerGetBalanceQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the user's available balances for all supported token types (SOL, AFEL). This is useful for showing users their total holdings across different tokens in the gaming platform.
 * @summary Get all token balances for user
 */
export const gamesControllerGetAllBalances = (
    params: GamesControllerGetAllBalancesParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<BalanceResponse[]>(
      {url: `/games/balances`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGamesControllerGetAllBalancesQueryKey = (params: GamesControllerGetAllBalancesParams,) => {
    return [`/games/balances`, ...(params ? [params]: [])] as const;
    }

    
export const getGamesControllerGetAllBalancesQueryOptions = <TData = Awaited<ReturnType<typeof gamesControllerGetAllBalances>>, TError = void>(params: GamesControllerGetAllBalancesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetAllBalances>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGamesControllerGetAllBalancesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gamesControllerGetAllBalances>>> = ({ signal }) => gamesControllerGetAllBalances(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetAllBalances>>, TError, TData> & { queryKey: QueryKey }
}

export type GamesControllerGetAllBalancesQueryResult = NonNullable<Awaited<ReturnType<typeof gamesControllerGetAllBalances>>>
export type GamesControllerGetAllBalancesQueryError = void


/**
 * @summary Get all token balances for user
 */

export function useGamesControllerGetAllBalances<TData = Awaited<ReturnType<typeof gamesControllerGetAllBalances>>, TError = void>(
 params: GamesControllerGetAllBalancesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof gamesControllerGetAllBalances>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGamesControllerGetAllBalancesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint processes deposits to the user account for gaming purposes. It validates the transaction signature on the blockchain before crediting the funds to the user's balance. The deposit can be made in SOL or AFEL tokens, depending on the specified tokenType. The receiver wallet address must match the application's designated wallet.
 * @summary Deposit funds for games
 */
export const gamesControllerDeposit = (
    walletDepositRequest: WalletDepositRequest,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WalletDepositResponse>(
      {url: `/games/deposit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: walletDepositRequest, signal
    },
      options);
    }
  


export const getGamesControllerDepositMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerDeposit>>, TError,{data: WalletDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof gamesControllerDeposit>>, TError,{data: WalletDepositRequest}, TContext> => {

const mutationKey = ['gamesControllerDeposit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gamesControllerDeposit>>, {data: WalletDepositRequest}> = (props) => {
          const {data} = props ?? {};

          return  gamesControllerDeposit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GamesControllerDepositMutationResult = NonNullable<Awaited<ReturnType<typeof gamesControllerDeposit>>>
    export type GamesControllerDepositMutationBody = WalletDepositRequest
    export type GamesControllerDepositMutationError = void

    /**
 * @summary Deposit funds for games
 */
export const useGamesControllerDeposit = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerDeposit>>, TError,{data: WalletDepositRequest}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof gamesControllerDeposit>>,
        TError,
        {data: WalletDepositRequest},
        TContext
      > => {

      const mutationOptions = getGamesControllerDepositMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Processes withdrawals from Slot Machine game accounts with a 2% commission fee. The requested amount will have the commission deducted before processing the blockchain transaction. For example, if withdrawing 100 SOL, 2 SOL will be retained as commission and 98 SOL will be sent to the user's wallet. The minimum withdrawal amounts are 0.025 SOL for SOL tokens and 1 AFEL for AFEL tokens.
 * @summary Withdraw funds from Slot Machine games
 */
export const gamesControllerWithdrawFromSlotMachine = (
    withdrawRequestDto: WithdrawRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WithdrawResponse>(
      {url: `/games/withdraw/slotmachine`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: withdrawRequestDto, signal
    },
      options);
    }
  


export const getGamesControllerWithdrawFromSlotMachineMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>, TError,{data: WithdrawRequestDto}, TContext> => {

const mutationKey = ['gamesControllerWithdrawFromSlotMachine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>, {data: WithdrawRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  gamesControllerWithdrawFromSlotMachine(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GamesControllerWithdrawFromSlotMachineMutationResult = NonNullable<Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>>
    export type GamesControllerWithdrawFromSlotMachineMutationBody = WithdrawRequestDto
    export type GamesControllerWithdrawFromSlotMachineMutationError = void

    /**
 * @summary Withdraw funds from Slot Machine games
 */
export const useGamesControllerWithdrawFromSlotMachine = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof gamesControllerWithdrawFromSlotMachine>>,
        TError,
        {data: WithdrawRequestDto},
        TContext
      > => {

      const mutationOptions = getGamesControllerWithdrawFromSlotMachineMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Processes withdrawals from Coin Flip game accounts with a 2% commission fee. The requested amount will have the commission deducted before processing the blockchain transaction. For example, if withdrawing 100 SOL, 2 SOL will be retained as commission and 98 SOL will be sent to the user's wallet. The minimum withdrawal amounts are 0.025 SOL for SOL tokens and 1 AFEL for AFEL tokens.
 * @summary Withdraw funds from Coin Flip games
 */
export const gamesControllerWithdrawFromCoinFlip = (
    withdrawRequestDto: WithdrawRequestDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<WithdrawResponse>(
      {url: `/games/withdraw/coinflip`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: withdrawRequestDto, signal
    },
      options);
    }
  


export const getGamesControllerWithdrawFromCoinFlipMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>, TError,{data: WithdrawRequestDto}, TContext> => {

const mutationKey = ['gamesControllerWithdrawFromCoinFlip'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>, {data: WithdrawRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  gamesControllerWithdrawFromCoinFlip(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GamesControllerWithdrawFromCoinFlipMutationResult = NonNullable<Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>>
    export type GamesControllerWithdrawFromCoinFlipMutationBody = WithdrawRequestDto
    export type GamesControllerWithdrawFromCoinFlipMutationError = void

    /**
 * @summary Withdraw funds from Coin Flip games
 */
export const useGamesControllerWithdrawFromCoinFlip = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>, TError,{data: WithdrawRequestDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof gamesControllerWithdrawFromCoinFlip>>,
        TError,
        {data: WithdrawRequestDto},
        TContext
      > => {

      const mutationOptions = getGamesControllerWithdrawFromCoinFlipMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Initiates a slot machine game with the specified bet amount and token type. The slot machine generates three random symbols based on weighted probabilities. Winnings are calculated based on matching symbols and their corresponding payout multipliers. Two matching symbols result in a smaller win, while three matching symbols result in a larger win. The result includes the generated symbols, win status, multiplier applied, bet amount, win amount, and balance information before and after the game.
 * @summary Play Slot Machine Game
 */
export const slotMachineControllerPlay = (
    playSlotMachineDto: PlaySlotMachineDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<SlotMachineResultDto>(
      {url: `/games/slotmachine/play`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: playSlotMachineDto, signal
    },
      options);
    }
  


export const getSlotMachineControllerPlayMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof slotMachineControllerPlay>>, TError,{data: PlaySlotMachineDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof slotMachineControllerPlay>>, TError,{data: PlaySlotMachineDto}, TContext> => {

const mutationKey = ['slotMachineControllerPlay'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof slotMachineControllerPlay>>, {data: PlaySlotMachineDto}> = (props) => {
          const {data} = props ?? {};

          return  slotMachineControllerPlay(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SlotMachineControllerPlayMutationResult = NonNullable<Awaited<ReturnType<typeof slotMachineControllerPlay>>>
    export type SlotMachineControllerPlayMutationBody = PlaySlotMachineDto
    export type SlotMachineControllerPlayMutationError = void

    /**
 * @summary Play Slot Machine Game
 */
export const useSlotMachineControllerPlay = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof slotMachineControllerPlay>>, TError,{data: PlaySlotMachineDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof slotMachineControllerPlay>>,
        TError,
        {data: PlaySlotMachineDto},
        TContext
      > => {

      const mutationOptions = getSlotMachineControllerPlayMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Retrieves the history of slot machine games played by a specific user account. Results are paginated and ordered by creation date (newest first). Each game record includes the symbols generated, bet amount, win amount, win multiplier, whether the game was won or lost, and the timestamp of when the game was played.
 * @summary Get Slot Machine Game History
 */
export const slotMachineControllerGetHistory = (
    params: SlotMachineControllerGetHistoryParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<SlotMachineHistoryResponse>(
      {url: `/games/slotmachine/history`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSlotMachineControllerGetHistoryQueryKey = (params: SlotMachineControllerGetHistoryParams,) => {
    return [`/games/slotmachine/history`, ...(params ? [params]: [])] as const;
    }

    
export const getSlotMachineControllerGetHistoryQueryOptions = <TData = Awaited<ReturnType<typeof slotMachineControllerGetHistory>>, TError = void>(params: SlotMachineControllerGetHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSlotMachineControllerGetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof slotMachineControllerGetHistory>>> = ({ signal }) => slotMachineControllerGetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type SlotMachineControllerGetHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof slotMachineControllerGetHistory>>>
export type SlotMachineControllerGetHistoryQueryError = void


/**
 * @summary Get Slot Machine Game History
 */

export function useSlotMachineControllerGetHistory<TData = Awaited<ReturnType<typeof slotMachineControllerGetHistory>>, TError = void>(
 params: SlotMachineControllerGetHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSlotMachineControllerGetHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves comprehensive statistics about a user's performance in slot machine games for a specific token type. Statistics include total games played, wins and losses count, win rate percentage, financial metrics (total bet amount, total winnings, net profit), average win multiplier, frequency distribution of each symbol, and the largest single win amount.
 * @summary Get User Slot Machine Statistics
 */
export const slotMachineControllerGetStats = (
    params: SlotMachineControllerGetStatsParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<SlotMachineStats>(
      {url: `/games/slotmachine/stats`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSlotMachineControllerGetStatsQueryKey = (params: SlotMachineControllerGetStatsParams,) => {
    return [`/games/slotmachine/stats`, ...(params ? [params]: [])] as const;
    }

    
export const getSlotMachineControllerGetStatsQueryOptions = <TData = Awaited<ReturnType<typeof slotMachineControllerGetStats>>, TError = void>(params: SlotMachineControllerGetStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSlotMachineControllerGetStatsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof slotMachineControllerGetStats>>> = ({ signal }) => slotMachineControllerGetStats(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetStats>>, TError, TData> & { queryKey: QueryKey }
}

export type SlotMachineControllerGetStatsQueryResult = NonNullable<Awaited<ReturnType<typeof slotMachineControllerGetStats>>>
export type SlotMachineControllerGetStatsQueryError = void


/**
 * @summary Get User Slot Machine Statistics
 */

export function useSlotMachineControllerGetStats<TData = Awaited<ReturnType<typeof slotMachineControllerGetStats>>, TError = void>(
 params: SlotMachineControllerGetStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof slotMachineControllerGetStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSlotMachineControllerGetStatsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Places a bet on the coin flip game with specified parameters. Player chooses HEADS or TAILS, and places a bet. The coin is flipped and if the player guessed correctly, they win double their bet amount (minus 2% commission). The result, winning status, and updated balance information are returned. Each play generates a unique transactionId for tracking purposes.
 * @summary Play Coin Flip Game
 */
export const coinFlipControllerPlay = (
    playCoinFlipDto: PlayCoinFlipDto,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<CoinFlipResultDto>(
      {url: `/games/coinflip/play`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: playCoinFlipDto, signal
    },
      options);
    }
  


export const getCoinFlipControllerPlayMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coinFlipControllerPlay>>, TError,{data: PlayCoinFlipDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coinFlipControllerPlay>>, TError,{data: PlayCoinFlipDto}, TContext> => {

const mutationKey = ['coinFlipControllerPlay'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coinFlipControllerPlay>>, {data: PlayCoinFlipDto}> = (props) => {
          const {data} = props ?? {};

          return  coinFlipControllerPlay(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoinFlipControllerPlayMutationResult = NonNullable<Awaited<ReturnType<typeof coinFlipControllerPlay>>>
    export type CoinFlipControllerPlayMutationBody = PlayCoinFlipDto
    export type CoinFlipControllerPlayMutationError = void

    /**
 * @summary Play Coin Flip Game
 */
export const useCoinFlipControllerPlay = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coinFlipControllerPlay>>, TError,{data: PlayCoinFlipDto}, TContext>, request?: SecondParameter<typeof getAxiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coinFlipControllerPlay>>,
        TError,
        {data: PlayCoinFlipDto},
        TContext
      > => {

      const mutationOptions = getCoinFlipControllerPlayMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Retrieves the history of coin flip games played by a specific user account. Results are paginated and ordered by creation date (newest first). Each game record includes the chosen side, result, bet amount, win amount, and whether the game was won or lost.
 * @summary Get Coin Flip Game History
 */
export const coinFlipControllerGetHistory = (
    params: CoinFlipControllerGetHistoryParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<CoinFlipHistoryResponse>(
      {url: `/games/coinflip/history`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getCoinFlipControllerGetHistoryQueryKey = (params: CoinFlipControllerGetHistoryParams,) => {
    return [`/games/coinflip/history`, ...(params ? [params]: [])] as const;
    }

    
export const getCoinFlipControllerGetHistoryQueryOptions = <TData = Awaited<ReturnType<typeof coinFlipControllerGetHistory>>, TError = void>(params: CoinFlipControllerGetHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoinFlipControllerGetHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coinFlipControllerGetHistory>>> = ({ signal }) => coinFlipControllerGetHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type CoinFlipControllerGetHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof coinFlipControllerGetHistory>>>
export type CoinFlipControllerGetHistoryQueryError = void


/**
 * @summary Get Coin Flip Game History
 */

export function useCoinFlipControllerGetHistory<TData = Awaited<ReturnType<typeof coinFlipControllerGetHistory>>, TError = void>(
 params: CoinFlipControllerGetHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetHistory>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoinFlipControllerGetHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves comprehensive statistics about a user's performance in coin flip games for a specific token type. Statistics include total games played, win/loss ratio, total amounts bet and won, net profit, distribution of heads/tails results, and largest win amount.
 * @summary Get User Coin Flip Statistics
 */
export const coinFlipControllerGetStats = (
    params: CoinFlipControllerGetStatsParams,
 options?: SecondParameter<typeof getAxiosInstance>,signal?: AbortSignal
) => {
      
      
      return getAxiosInstance<CoinFlipStats>(
      {url: `/games/coinflip/stats`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getCoinFlipControllerGetStatsQueryKey = (params: CoinFlipControllerGetStatsParams,) => {
    return [`/games/coinflip/stats`, ...(params ? [params]: [])] as const;
    }

    
export const getCoinFlipControllerGetStatsQueryOptions = <TData = Awaited<ReturnType<typeof coinFlipControllerGetStats>>, TError = void>(params: CoinFlipControllerGetStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoinFlipControllerGetStatsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coinFlipControllerGetStats>>> = ({ signal }) => coinFlipControllerGetStats(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetStats>>, TError, TData> & { queryKey: QueryKey }
}

export type CoinFlipControllerGetStatsQueryResult = NonNullable<Awaited<ReturnType<typeof coinFlipControllerGetStats>>>
export type CoinFlipControllerGetStatsQueryError = void


/**
 * @summary Get User Coin Flip Statistics
 */

export function useCoinFlipControllerGetStats<TData = Awaited<ReturnType<typeof coinFlipControllerGetStats>>, TError = void>(
 params: CoinFlipControllerGetStatsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coinFlipControllerGetStats>>, TError, TData>, request?: SecondParameter<typeof getAxiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoinFlipControllerGetStatsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
